Tasks (in order):
[X] Create a command line argument parser with 'clap' library
[X] Get file content and filter it to remove comments and empty lines
[X] Check puzzle size (as N in range [3, 100])
[X] Check puzzle validity (puzzle size, correct number of cols and rows, valid numbers, numbers in range, duplicate numbers)
[X] Generate goal state depending on its style (snail, ascending or descending)
[X] Check if the puzzle is solvable
[X] Create Unit tests and Integration tests
[X] Create a generator of random puzzles available from command line
[X] Create heuristic functions
[?] Decide to use either async with tokio crate (if possible) or multithreading with crossbeam / rayon crate
[X] Create open set as a priority queue with F cost as priority
[X] Create close set as a hash map (see Optimization section)
[X] Create A* algo with its variants (weighted, greedy, uniform cost)
[ ] Create function(s) to print solution (complexity of time & memory, number of moves, each state of final path, exec time)
[-] Build UI in JS and link it to project with webassembly
[-] Build a play mode for UI

Optimizations:
(MT) tag stands for MultiThreading. Every optimizations with (MT) tag will run at the same time and wait for each other

- (MT) Run heuristic function on state of possible moves at the same time with multithreading

- Create goal state as Vector<usize> with tile values as indexes and their indexes as values
	=> This enables an easy access of goal position for a specific tile to calculate heuristic value faster

- Create each state as Vector<usize> inside a 'State' structure and keep position of empty tile
	=> This enables to access directly the tile to move and do simple maths to know positions of possible moves
	=> for empty position 'E' and puzzle size 'N' as in 'N'-Puzzle:
		- E - N to move UP
		- E + N to move DOWN
		- E - 1 to move LEFT
		- E + 1 to move RIGHT

- Put #[inline] tag for small functions called many times in solver to speed up runtime
